# coding: utf-8

"""
    Metal API

    desc  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: support@equinixmetal.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, validator
from equinix_metal.models.device_actions_inner import DeviceActionsInner
from equinix_metal.models.device_created_by import DeviceCreatedBy
from equinix_metal.models.device_metro import DeviceMetro
from equinix_metal.models.device_project import DeviceProject
from equinix_metal.models.device_project_lite import DeviceProjectLite
from equinix_metal.models.event import Event
from equinix_metal.models.facility import Facility
from equinix_metal.models.href import Href
from equinix_metal.models.ip_assignment import IPAssignment
from equinix_metal.models.operating_system import OperatingSystem
from equinix_metal.models.plan import Plan
from equinix_metal.models.port import Port

class Device(BaseModel):
    """
    Device
    """
    actions: Optional[conlist(DeviceActionsInner)] = Field(None, description="Actions supported by the device instance.")
    always_pxe: Optional[StrictBool] = None
    billing_cycle: Optional[StrictStr] = None
    bonding_mode: Optional[StrictInt] = None
    created_at: Optional[datetime] = None
    created_by: Optional[DeviceCreatedBy] = None
    customdata: Optional[Dict[str, Any]] = None
    description: Optional[StrictStr] = None
    facility: Optional[Facility] = None
    hardware_reservation: Optional[Href] = None
    hostname: Optional[StrictStr] = None
    href: Optional[StrictStr] = None
    id: Optional[StrictStr] = None
    image_url: Optional[StrictStr] = None
    ip_addresses: Optional[conlist(IPAssignment)] = None
    ipxe_script_url: Optional[StrictStr] = None
    iqn: Optional[StrictStr] = None
    locked: Optional[StrictBool] = None
    metro: Optional[DeviceMetro] = None
    network_ports: Optional[conlist(Port)] = Field(None, description="By default, servers at Equinix Metal are configured in a “bonded” mode using LACP (Link Aggregation Control Protocol). Each 2-NIC server is configured with a single bond (namely bond0) with both interfaces eth0 and eth1 as members of the bond in a default Layer 3 mode. Some device plans may have a different number of ports and bonds available.")
    operating_system: Optional[OperatingSystem] = None
    plan: Optional[Plan] = None
    project: Optional[DeviceProject] = None
    project_lite: Optional[DeviceProjectLite] = None
    provisioning_events: Optional[conlist(Event)] = None
    provisioning_percentage: Optional[StrictFloat] = Field(None, description="Only visible while device provisioning")
    root_password: Optional[StrictStr] = Field(None, description="Root password is automatically generated when server is provisioned and it is removed after 24 hours")
    short_id: Optional[StrictStr] = None
    sos: Optional[StrictStr] = Field(None, description="Hostname used to connect to the instance via the SOS (Serial over SSH) out-of-band console.")
    spot_instance: Optional[StrictBool] = Field(None, description="Whether or not the device is a spot instance.")
    spot_price_max: Optional[StrictFloat] = Field(None, description="The maximum price per hour you are willing to pay to keep this spot instance.  If you are outbid, the termination will be set allowing two minutes before shutdown.")
    ssh_keys: Optional[conlist(Href)] = None
    state: Optional[StrictStr] = None
    switch_uuid: Optional[StrictStr] = Field(None, description="Switch short id. This can be used to determine if two devices are connected to the same switch, for example.")
    tags: Optional[conlist(StrictStr)] = None
    termination_time: Optional[datetime] = Field(None, description="When the device will be terminated. This is commonly set in advance for ephemeral spot market instances but this field may also be set with on-demand and reservation instances to automatically delete the resource at a given time. The termination time can also be used to release a hardware reservation instance at a given time, keeping the reservation open for other uses.  On a spot market device, the termination time will be set automatically when outbid.")
    updated_at: Optional[datetime] = None
    user: Optional[StrictStr] = None
    userdata: Optional[StrictStr] = None
    volumes: Optional[conlist(Href)] = None
    __properties = ["actions", "always_pxe", "billing_cycle", "bonding_mode", "created_at", "created_by", "customdata", "description", "facility", "hardware_reservation", "hostname", "href", "id", "image_url", "ip_addresses", "ipxe_script_url", "iqn", "locked", "metro", "network_ports", "operating_system", "plan", "project", "project_lite", "provisioning_events", "provisioning_percentage", "root_password", "short_id", "sos", "spot_instance", "spot_price_max", "ssh_keys", "state", "switch_uuid", "tags", "termination_time", "updated_at", "user", "userdata", "volumes"]

    @validator('state')
    def state_validate_enum(cls, v):
        if v is None:
            return v
        if v not in ('active', 'deleted', 'deprovisioning', 'failed', 'inactive', 'queued', 'reinstalling', 'post_provisioning', 'powering_on', 'powering_off', 'provisioning'):
            raise ValueError("must be one of enum values ('active', 'deleted', 'deprovisioning', 'failed', 'inactive', 'queued', 'reinstalling', 'post_provisioning', 'powering_on', 'powering_off', 'provisioning')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Device:
        """Create an instance of Device from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in actions (list)
        _items = []
        if self.actions:
            for _item in self.actions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['actions'] = _items
        # override the default output from pydantic by calling `to_dict()` of created_by
        if self.created_by:
            _dict['created_by'] = self.created_by.to_dict()
        # override the default output from pydantic by calling `to_dict()` of facility
        if self.facility:
            _dict['facility'] = self.facility.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hardware_reservation
        if self.hardware_reservation:
            _dict['hardware_reservation'] = self.hardware_reservation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ip_addresses (list)
        _items = []
        if self.ip_addresses:
            for _item in self.ip_addresses:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ip_addresses'] = _items
        # override the default output from pydantic by calling `to_dict()` of metro
        if self.metro:
            _dict['metro'] = self.metro.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in network_ports (list)
        _items = []
        if self.network_ports:
            for _item in self.network_ports:
                if _item:
                    _items.append(_item.to_dict())
            _dict['network_ports'] = _items
        # override the default output from pydantic by calling `to_dict()` of operating_system
        if self.operating_system:
            _dict['operating_system'] = self.operating_system.to_dict()
        # override the default output from pydantic by calling `to_dict()` of plan
        if self.plan:
            _dict['plan'] = self.plan.to_dict()
        # override the default output from pydantic by calling `to_dict()` of project
        if self.project:
            _dict['project'] = self.project.to_dict()
        # override the default output from pydantic by calling `to_dict()` of project_lite
        if self.project_lite:
            _dict['project_lite'] = self.project_lite.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in provisioning_events (list)
        _items = []
        if self.provisioning_events:
            for _item in self.provisioning_events:
                if _item:
                    _items.append(_item.to_dict())
            _dict['provisioning_events'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ssh_keys (list)
        _items = []
        if self.ssh_keys:
            for _item in self.ssh_keys:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ssh_keys'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in volumes (list)
        _items = []
        if self.volumes:
            for _item in self.volumes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['volumes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Device:
        """Create an instance of Device from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return Device.parse_obj(obj)

        _obj = Device.parse_obj({
            "actions": [DeviceActionsInner.from_dict(_item) for _item in obj.get("actions")] if obj.get("actions") is not None else None,
            "always_pxe": obj.get("always_pxe"),
            "billing_cycle": obj.get("billing_cycle"),
            "bonding_mode": obj.get("bonding_mode"),
            "created_at": obj.get("created_at"),
            "created_by": DeviceCreatedBy.from_dict(obj.get("created_by")) if obj.get("created_by") is not None else None,
            "customdata": obj.get("customdata"),
            "description": obj.get("description"),
            "facility": Facility.from_dict(obj.get("facility")) if obj.get("facility") is not None else None,
            "hardware_reservation": Href.from_dict(obj.get("hardware_reservation")) if obj.get("hardware_reservation") is not None else None,
            "hostname": obj.get("hostname"),
            "href": obj.get("href"),
            "id": obj.get("id"),
            "image_url": obj.get("image_url"),
            "ip_addresses": [IPAssignment.from_dict(_item) for _item in obj.get("ip_addresses")] if obj.get("ip_addresses") is not None else None,
            "ipxe_script_url": obj.get("ipxe_script_url"),
            "iqn": obj.get("iqn"),
            "locked": obj.get("locked"),
            "metro": DeviceMetro.from_dict(obj.get("metro")) if obj.get("metro") is not None else None,
            "network_ports": [Port.from_dict(_item) for _item in obj.get("network_ports")] if obj.get("network_ports") is not None else None,
            "operating_system": OperatingSystem.from_dict(obj.get("operating_system")) if obj.get("operating_system") is not None else None,
            "plan": Plan.from_dict(obj.get("plan")) if obj.get("plan") is not None else None,
            "project": DeviceProject.from_dict(obj.get("project")) if obj.get("project") is not None else None,
            "project_lite": DeviceProjectLite.from_dict(obj.get("project_lite")) if obj.get("project_lite") is not None else None,
            "provisioning_events": [Event.from_dict(_item) for _item in obj.get("provisioning_events")] if obj.get("provisioning_events") is not None else None,
            "provisioning_percentage": obj.get("provisioning_percentage"),
            "root_password": obj.get("root_password"),
            "short_id": obj.get("short_id"),
            "sos": obj.get("sos"),
            "spot_instance": obj.get("spot_instance"),
            "spot_price_max": obj.get("spot_price_max"),
            "ssh_keys": [Href.from_dict(_item) for _item in obj.get("ssh_keys")] if obj.get("ssh_keys") is not None else None,
            "state": obj.get("state"),
            "switch_uuid": obj.get("switch_uuid"),
            "tags": obj.get("tags"),
            "termination_time": obj.get("termination_time"),
            "updated_at": obj.get("updated_at"),
            "user": obj.get("user"),
            "userdata": obj.get("userdata"),
            "volumes": [Href.from_dict(_item) for _item in obj.get("volumes")] if obj.get("volumes") is not None else None
        })
        return _obj

